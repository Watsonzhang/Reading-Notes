### 前言
    第一部分 数据结构
    第二部分 单机数据库实现
    第三部分 多机数据库的实现
    第四部分 独立功能的实现
    
### 第一部分 数据结构与对象
#### 第二章 简单动态字符串
    2.1 SDS(simple dynamic string) 简单动态字符串
    struct{
        int free;
        int len;
        char buf[];
    }
    2.2 SDS与C字符串的区别
        2.2.1 常数复杂度获取字符串长度
        2.2.2 杜绝缓冲区溢出
        2.2.3 减少修改字符串带来的内存重分配次数
            1.空间预分配
            2.惰性空间释放
        2.2.4 二进制安全
        2.2.5 兼容部分C字符串函数
#### 第三章 链表 
    3.1 链表和链表节点实现
    typedef struct listNode{
        struct listNode * prev;
        struct lsitNode * next;
        void * value;
    }        
     typedef sturct  list{
        listNode * head;
        listNode * tail;
        unsigned long len;
     } list;  
     redis链表：双端链表
#### 第四章 字典
    4.1 字典的实现
        4.1.1 哈希表
        trpedef sruct dictht{
        dictEntry ** table;
        unsigned long size;
        unsigned long sizemask;
        }  dictht;   
        4.1.2 哈希表节点
        4.1.3 字典
    4.2 哈希算法
    4.3 解决随机冲突
    4.4 rehash
    4.5 渐进式rehash
### 第五章 跳跃表
### 第六章 整数集合
    typedef struct inset{
    uint32_t encoding;
    uint32_t length;
    int8_t contents[];
    }inset;
### 第七章 压缩列表
### 第八章 对象
    redis并没有直接使用这些数据结构来实现键值对数据库 而是基于这些数据结构创建了一个对象系统，
    这个系统包含了字符串对象 列表对象 哈希对象 集合对象 有序集合对象这五种类型对象，
    redis实现了基于引用就似乎的内存回收机制，当程序不再使用某个对象时，这个对象所占用的内存就会被自动释放。
    8.1 对象的类型和编码
        例如 redis> set msg “hello”;
        创建了msg独对象与hello 对象
        而每个对象都由一个redisObject结构表示
        typedef struct redisObject{
            unsigned type:4;
            unsigned encoding:4;
            void *ptr;
        }robj;
        8.1.1 类型
            REDIS_STRING REDIS_LIST REDIS_HASH REDIS_SET REDIS_ZSET
         当我们称呼一个数据库键为字符串键，指这个是数据库所对应的值为字符串对象，同理类推，
    8.2 字符串对象
    8.3 列表对象
        列表对象的编码可以使ziplist 或者linklist
    8.4 哈希对象
    8.5 集合对象
    8.6 有序集合对象
    8.7 类型检查与命令多态
        其中一种命令可以对任何类型的键执行比如del expire rename type object
        另一种命令只能对特定类型的键执行
        8.7.1 类型检查的实现
         在执行一个特定类型的命令之前 redis会检查输入键的类型是否正确 然后再决定是否执行给定的命令。
        8.7.2 多态命令的实现
    8.8 内存回收
        type struct redisObject{
            int refcount;
        } robj;
    8.9 对象共享
    8.10 对象的空转时长
        redisObject包含了一个属性为lru的属性，该属性记录了对象最后依次被命令程序访问的时间
        typedef stuct  redfisObject{
        unsigned lru:22;
        }robj;
        空转时长=当前时间-lru时间
    8.11 重点回顾
        redis数据库的键值对的键和值都是一个对象
        redis共有字符串 列表 哈希 集合 有序集合 五种类型的对象 
        每种类型的对象至少都有两种或者以上的编码方式，不同 的编码可以在不同的使用场景上优化对象的使用效率；
        服务器在执行某种命令之前 会检查给定类型能否执行指定的命令 而检查一个键的类型就是检查键的值对象的类型。
### 单机数据库的实现
#### 第九章 数据库        
    9.1 服务器中的数据库
        struct redisServer{
        一个数组 存放服务器中所有的数据库
        redisDb *db;
        //库的数量
        int dbnum;
        }
    9.2 切换数据库
        typedef struct redisClient{
        //记录客户端当前正在使用的数据库
        redisDb * db;
       }
    9.3 数据库键空间
        键空间是个字典
        typedef struct redisDb{
        dict *dict;
        }redisDb;   
        9.3.1 添加新键
        9.3.2 删除键
        9.3.3 更新键
        9.3.4 对键取值
        9.3.5 其他键空间操作
        9.3.6 读写键空间时的维护操作
    9.4 设置键的生存时间或者过期时间
        通过expire命令或者pexpire命令 客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间
        setex 命令可以在设置一个字符串键的同时为键设置过期时间
        9.4.1 设置过期时间
        9.4.2 保存过期时间
        typedef struct redisDb{
            dict *expires;
        }redisDb;
        9.4.3  移除过期时间
        9.4.4  计算并返回剩余的生存时间
        9.4.5  过期键的判定
            1)检查给定键是否存在于过期字典 如果存在 那么取得键的过期时间
            2)检查当前的unix时间戳是否大于键的过期时间
    9.5 过期键删除策略
        9.5.1 定时删除
        9.5.2 惰性删除 ：对cpu时间来说时最友好的 程序只会在去除键时才对键值对进行过期检查
        9.5.3 定期删除                 
    9.6 redisd的过期键删除策略
        惰性删除+定期删除
    9.7 AOF.RDB 和复制功能对过期键的处理
        9.7.1 生成RDB文件
        在执行save命令或者bgSave命令创建一个新的RDB文件 
        程序对数据库中的键进行检查 已过期的键不会被保存到新创建的RDB文件
        9.7.2 载入RDB 文件
        如果服务器以主服务器模式运行 那么在载入        
        RDB文件时，程序对文件中保存的键进行检查 未过期的键会被载入到数据库中而过期键则会被忽略 所以过期键对载入
        RDB文件的主服务器不会造成影响。如果服务器以从服务器模式运行 那么在载入RDB文件 文件中保存的所有的键不论是否过期 
        都会被载入到数据库中。
        9.7.3 AOF文件写入
         当服务器以AOF持久化模式进行运行时，如果数据库中某个键已经过期 但没有定期删除或者惰性删除 则aof文件不会产生影响
         但是当被删除时，aof文件会追加一条del命令
        9.7.4 AOF 重写
    9.8 数据库通知
        键空间通知
        键事件通知
    9.9 重点回顾
### 第十章 RDB持久化
    可以将某个时间点上数据库状态保存到一个RDB文件中.
    RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB数据库状态.
    10.1 RDB文件的创建和载入
        SAVE 会阻塞redis服务进程
        BGSAVE  派生子进程处理命令请求
        由于aof文件更新频率通常比RDB文件的更新频率搞，所以
            如果开启了aof 优先使用aof文件来还原数据库状态
            只有aof持久化关闭时，服务器采用rdb恢复数据库状态
        10.1.1 SAVE命令执行时的服务器状态
            所以请求都会被拒绝
        10.1.2 BGSAVE命令执行时的服务器状态
            服务器正常处理客户端请求
        10.1.3 RDB文件载入时的服务器状态
            服务器处于阻塞状态
    10.2 自动间隔性保存
        REDIS允许用户通过设置服务器配置的save选项。让服务器每隔一段时间自动执行一次BGSAVE
        例如
            save 900 1
            save 300 10
            save 60  10000
        10.2.1 设置保存条件
        10.2.2 dirty计数器和lastsave属性
            dirty记录服务器对数据库状态进行了多少次修改
            lasesave属性是一个unix时间戳记录了服务器上一次成功执行save命令或者bgsave命令时间
        10.2.3 检查保存条件是否满足
            周期性操作函数 serverCron 默认每隔100毫秒就会执行一次         
            检查save选项所设置的保存条件是否满足 如果满足则执行BGSAVE
    10.3 RDB文件结构
        redis db_version database eof check_sum
        10.3.1 databases部分
        10.3.2 key_value_pairs 部分
    10.4 分析RDB文件
 ### 第十一章  AOF持久化
    AOF时是服务器所执行的写命令来记录数据库状态的
    11.1 AOF持久化的实现
    命令追加 文件写入 文件同步
        11.1.1 命令追加
        11.1.2 AOF文件的写入与同步
            redis 服务器进程就是一个事件循环loop，
            这个循环中的文件事件负责接收客户端的命令请求，
            以及向客户端发送命令回复，而时间时间负责执行serverCron
           在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面 所以服务器每次结束一个事件循环之前
           考虑是否需要将aof——buf缓冲区中的内容写入和保存到aof里面
           文件的写入与同步
           always everysec no 
           always会丢失一次循环的数据
           everyesc 丢失一秒的数据
           no 丢失上次同步以来的数据
    11.2 AOF文件的载入和数据还原
    11.3 AOF重写
        aof_rewrite 函数生成的新aof文件 只包含还原当前数据库状态所必须的命令
         11.3.1 aof文件重写的实现
         11.3.2 aof后台重写
            子进程进行aof重写期间 服务器进程可以继续处理命令请求
            子进程带有服务器进程的数据副本 使用子进程而不是线程，可以避免使用锁的情况
 ### 第十二章 事件
    文件事件：redis服务器通过套接字与客户端进行连接 而文件事件就是服务器对套接字操作的抽象。
    服务端与客户端的通信就会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信
    时间事件： redis服务器中的一些操作需要在给定时间点执行，而时间事件就是服务器对这类定时操作的抽象
    12.1 文件事件
        文件事件处理器使用IO多路复用程序来同事监听多个套接字 并根据套接字目前执行的任务来为套接字关联不同的事件处理器
        当监听的套接字准备好执行连接应答 读取 写入 关闭等操作，与操作对应的文件事件就会产生，
        这时文件处理器就会调用套接字之前关联号的事件处理器来处理这些事件。
        虽然文件处理器以单线程方式运行 但通过IO多路复用来监听多个套接字
        12.1.1
            套接字 IO多路复用程序 文件事件派发器 事件处理器
        12.1.2 IO多路复用程序的实现
            select epoll evport kqueue
        12.1.3 事件的类型
        12.1.4 API
        12.1.5 文件事件的处理器
            连接应答处理器
            命令请求处理器
            命令回复处理器
            复制处理器
    12.2 时间事件
        定时事件
        周期性事件
        id:时间事件全局id
        when:记录时间事件到达的时间
        timeProc：时间事件处理器
        12.2.1 实现
        12.2.2 api
        12.2.3 时间事件应用实例：serverCron函数
    12.3 事件的调度与执行
### 第十三章 客户端
    redisClient 客户端状态就结构
        客户端套接字描述符
        客户端名字
        客户端的标识值
        指向客户端正在使用的数据库指针
        客户端当前需要执的命令
        客户端的输入缓冲和输出缓冲
        客户端复制状态信息
        客户端执行BRPOP  BLPOP等数组阻塞命令时使用的数据结构
        客户端的事务状态
        客户端使用发布订阅用到的数据结构
        客户端的身份证标志
        客户端的创建时间
    服务器状态结构clients是一个链表
        struct redisSeerver{
            list *clients;
        }
    13.1 客户端属性
        通用属性
        特定功能相关属性    
        13.1.1 套接字描述符
            typedef struct redisClient{
            int fd;
            }
            伪客户端和普通客户端
        13.1.2 名字
        13.1.3 标志
            客户端标志属性flag记录客户端的角色以及客户端目前所处的状态
        13.1.4 输入缓冲区
        13.1.5 命令与命令参数
            typedef struct redisClient{
                robj **argv;
                int argc;
            }
        13.1.7 输出缓冲区
            执行命令所得的命令恢复会被保存在客户端状体的输出缓冲区里面  
        13.1.8 身份验证
            客户端状态authenticated属性用于记录客户端是否通过了身份验证
        13.1.9 时间
### Lua脚本
    redis客户端使用lua脚本，可以直接在服务器端原子的执行多个redis命令.
    20.1创建并修改lua环境        
              
             
                        
                        
            
                
        
            