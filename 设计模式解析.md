### 关于模式    
    设计模式与敏捷管理和编程实践的关联
    测试驱动,极限编程
### 第一章 面向对象范式
    1.2面向对象范型之前：功能分解
    导致让一个主程序负责控制子程序，这是将功能分为多个子功能的自然结果，
    但是主程序所承受的责任太多了。
    许多bug都源于修改。
    如果程序同时关注过多的东西，一旦有变化只能坐等bug来到。
    1.4 应对变化：使用功能分解
    1.5 应对需求变更
       责任转移的重要性
    软件开发过程中的视角：
        概念：软件负责什么 规约：怎么使用软件 实现：软件怎样履行自己的责任
    1.6 面向对象范型
    何为对象？有责任的东西,对象应该自己负责自己，而且清楚的定义自己的责任
    martin flower视角来观察对象：
        概念层次上，对象是一组责任
        规约层次上，对象是一组可以被其他对象或者自调用的方法
        实现层次上，对象时代码和数据 以及他们之间的计算交互
    对象具有供其他对象使用的接口
    类是对对象行为的定义：
        对象所包含的数据元素
        对象能够操作的方法
        访问这些数据元素与方法的发方式
        规约上看：抽象类是其他类的占位符
    1.7 面向对象程序设计实践
    1.8 特殊对象方法
        构造方法和析构方法
        
    1：功能分解的基本方法？
        模块化
    2：导致需求变更原因
        需求不完整 错误 让人误解--->需求总是在变化
    3: 用责任而不是功能来思考
        责任思考可以分清不同对象边界
    4: 耦合与内聚的定义 什么是紧耦合
    低内聚：上帝对象 内聚是例程内部组成的紧密程度  例程与例程紧密程度
    5：对象接口的目的是什么
    共享基类没有的特性 希望每个类自己实现这些特性 
    6：类实例的定义
    7：类是对象行为完整定义 这句话说明了对象的哪三个方面
    8：抽象类的作用是什么
    定义实例的基础责任
    9:对象可能具有的三种主要可访问性是什么？
    10：给出封装的定义 并举出例子
    隐藏数据
    11：给出多态的含义 并举出多态的例子
    12 观察对象的三个视角是什么？ 
        概念 规约 实现
### 第二章 UML
    2.4 类图 
    is-a has-a use-a
    组合与聚合
    
### 第三部分 设计模式
    GOF “四人帮” Gamma Helm Johnson Vlissides
    facade adpater strategy bridge abstract factory
    在某个背景下问题的一种解决方案
    模式包括的四个要点：模式名称 模式的目的 实现方法 为了实现模式我们必修考虑的限制与约束因素
    优秀的建议：按接口编程 用聚合代替继承 找出变化并封装  
    facade 模式 为子系统中的一组接口提供一个统一接口，
    使用一个复杂系统的主要功能：
    意图:希望简化原有系统的使用方式，需要定义自己的接口
    问题：只需要使用摸个复杂系统的自己 需要以一种特殊的方式与系统交互
    解决方案：为原有系统的客户提供一个新的接口 为客户提供一个假话的接口 使系统更容易使用
    效果：让新的类使用原有的系统
    adapter模式 将一个类的接口转换成客户希望的另外一个接口 adapter模式使原本由于接口不兼容而不能一起工作的类可以一起工作
    adapter能继续保持多态
    对象：传统看法与新看法
    传统方法：具有方法的数据
    新看法：具有责任的实体
    关注动机而非实现 是设计模式中反复出现的主题
    封装：传统看法与新看法
    封装隐藏：实现细节,派生类 设计细节 实例化规则 
    封装的多种层次：数据的封装 方法的封装 其他对象的封装
    共性分析：寻找一些共同的要素 能够帮助啊我们理解系列成员的共同之处在哪
    
    面向对象设计涵盖的三种视角
        共性与变性分析
        概念视角 规约视角 实现视角
        抽象类及其接口和抽象的派生类
    预先设计与遍编程边设计    
    
    灾难往往时由短期未臻最优的决策 长期积累而引起的。
    软件开发也是如此：只关系眼前的事情，而忽视长期问题
    分析瘫痪与放任自流
    发展：接口编程,优先对象组合而不是类继承，考虑可变
    1,寻找变化 并将它封装在一个单独的类中
    2.将这个类包含在另一个类中
    策略模式定义：定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换，策略模式可以使算法可独立于使用它的客户而变化
    
    关键特征：算法都是完成相同的工作 只是实现的不同
    
    bridge 桥接模式
        将抽象与实现解耦 使他们都可以独立变化
       找出变化并封装之 和优先使用对象聚集而不是继承
    abstract  factory 模式
        为创建一组或相关依赖的对象提供一个接口 而且无需制定他们的具体类
    找到变化并封装之，优先使用对象聚集，而不是聚集，针对接口而不是实现设计
   
    <构造与使用分离>
    组合起来：用模式思考    
    
    抽象类可以可看成时聚集相关实体的方式，其关注点是如何设计具体的实体，从而可以以同样的方式使用它们。
    接口关注点是要使用这些派生实现的对象 服务对象应该有什么样的接口 才能服务于背景控制对象
    
    装饰者模式：为打印的票据添加表头 页脚信息
    
    装饰者模式并不通过一个控制方法控制新增功能，而是建议以需要的正确顺序将所需要功能串联起来，
    装饰者模式将这样一个功能链条的动态构建与使用功能的客户分离
    
    观察者模式-observer模型
    关于模式的分类：①创建性 抽象工厂 单例 DCL 工厂方法 ②结构型 facade adapter bridge decorator ③ 行为型 strategy
    
    observer 定义对象间的一种一对多的依赖关系 当一个对象状态发生改变时 所有依赖于它的对象 将得到通知并自动更新
    
  
      
    
       
    
                
           
       
    
    
    
    